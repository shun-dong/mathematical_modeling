function fis = genfis1(data, mf_n, in_mf_type, output_type)
% GENFIS1 Generates a Sugeno-type FIS structure used in ANFIS training.

% GENFIS1 Generate an FIS matrix from data without data clustering.
%   Synopsis
%   fismat = genfis1(data)
%   fismat = genfis1(data,numMFs,inmftype, outmftype)
%   Description
%   genfis1 generates a Sugeno-type FIS structure used as initial conditions
%   (initialization of the membership function parameters) for anfis training.
%   
%   genfis1(data, numMFs, inmftype, outmftype) generates a FIS structure from a
%   training data set, data, using a grid partition on the data (no
%   clustering). The output membership functions FIS generated by genfis1
%   The arguments for genfis1 are as follows:
%   data is the training data matrix, which must be entered with all the last
%   column representing input data, and the last column representing the single
%   output.
%   numMFs is a vector whose coordinates specify	the number of membership
%   functions associated with each input. If you want the same number of
%   membership functions to be associated with each input, then it suffices to
%   make numMFs a single number.
%   inmftype is a string array in which each row specifies the membership
%   function type associated with each input. Again, this can be one
%   dimensional single string if the type of membership functions associated
%   with each input is the same.
%   outmftype is a string that specifies the membership function type
%   associated with the output. There can only be one output, since this is a
%   Sugeno-type system. The output membership function type must be either
%   linear or constant.
%   The number of membership functions associated with the output is the same
%   as the number of rules generated by genfis1. The default number of
%   membership functions, numMFs, is 2; the default input or output membership
%   function type is 'gbellmf'. These are used whenever genfis1 is invoked
%   without the last three arguments.
%   Example
%   data = [rand(10,1) 10*rand(10,1)-5 rand(10,1)];
%   numMFs = [3 7];
%   mfType = str2mat('pimf','trimf');
%   fismat = genfis1(data,numMFs,mfType);
%   [x,mf] = plotmf(fismat,'input',1);
%   subplot(2,1,1), plot(x,mf);
%   xlabel('input 1 (pimf)');
%   [x,mf] = plotmf(fismat,'input',2);
%   subplot(2,1,2), plot(x,mf);
%   xlabel('input 2 (trimf)');
%		
%   See also GENPARAM, ANFIS.

%   Roger Jang, 8-7-94, Kelly Liu 7-30-96
%   Copyright (c) 1994-98 by The MathWorks, Inc.
%   $Revision: 1.18 $  $Date: 1997/12/01 21:45:00 $

% Change this to have different default values
default_mf_n = 2;
default_mf_type = 'gbellmf';
default_output_type = 'linear';

if nargin <= 3,
	output_type = default_output_type;
end
if nargin <= 2,
	in_mf_type = default_mf_type;
end
if nargin <= 1,
	mf_n = default_mf_n;
end

% get dimension info
data_n = size(data, 1);
in_n = size(data, 2) - 1;

% error checking
 if length(mf_n)==1,
   mf_n=mf_n*ones(1, in_n);
 end

if length(mf_n) ~= in_n | (size(in_mf_type, 1) ~=1 & size(in_mf_type, 1) ~= in_n),
	error('Wrong sizes of given argument(s)!');
end

if size(in_mf_type, 1) ==1 &  in_n>1
   for i=2:in_n
      in_mf_type(i,:)=in_mf_type(1,:);
   end
end

rule_n = prod(mf_n);

fis.name = 'anfis';
fis.type = 'sugeno';

fis.andMethod = 'prod';
fis.orMethod = 'max';
fis.defuzzMethod = 'wtaver';
fis.impMethod = 'prod';
fis.aggMethod = 'max';

range = [min(data)' max(data)'];
in_mf_param = genparam(data, mf_n, in_mf_type);
k=1;
for i = 1:in_n,
 fis.input(i).name = ['input' num2str(i)];
 fis.input(i).range=range(i,:);
 for j=1:mf_n(i)
  MFType = deblank(in_mf_type(i, :));
  fis.input(i).mf(j).name = ['in' num2str(i) 'mf' num2str(j)];
  fis.input(i).mf(j).type = MFType;
  if strcmp(MFType,'gaussmf') | strcmp(MFType,'sigmf') ...
                | strcmp(MFType,'smf'),
     fis.input(i).mf(j).params= in_mf_param(k,1:2);
  elseif strcmp(MFType,'trimf') | strcmp(MFType,'gbellmf'),
     fis.input(i).mf(j).params= in_mf_param(k,1:3);
  else
     fis.input(i).mf(j).params= in_mf_param(k,1:4);
  end  
  k=k+1;
 end
end

fis.output(1).name='output';

fis.output(1).range=range(end,:); 
for i = 1:rule_n,
  fis.output(1).mf(i).name=['out1mf', num2str(i)];  
  fis.output(1).mf(i).type=output_type;
  if (strcmp(output_type, 'linear')==1)
   fis.output(1).mf(i).params=[0 0 0];
  else
   fis.output(1).mf(i).params=[0];
  end
end

rule_list = zeros(rule_n, length(mf_n));
for i = 0:rule_n-1,
	tmp = i;
	for j = length(mf_n):-1:1,
		rule_list(i+1, j) = rem(tmp, mf_n(j))+1;
		tmp = fix(tmp/mf_n(j));
	end
end
rule_list = [rule_list (1:rule_n)' ones(rule_n, 1) ones(rule_n, 1)];
fis.rule=[];
fis=setfis(fis, 'rulelist', rule_list);
